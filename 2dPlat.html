<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2D Platformer - Fullscreen with Coins & Enemies</title>
<style>
  body, html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: linear-gradient(to top, #0b3d91, #1e90ff);
    font-family: Arial, sans-serif;
    color: white;
  }
  #score {
    position: fixed;
    top: 15px;
    left: 15px;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 1px 1px 3px #000;
    z-index: 10;
  }
  canvas {
    display: block;
    background: transparent;
  }
</style>
</head>
<body>

<div id="score">Score: 0</div>
<canvas id="gameCanvas"></canvas>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // Player setup
  const player = {
    x: 50,
    y: 0,
    width: 40,
    height: 60,
    color: '#ffeb3b',
    velocityY: 0,
    speedX: 5,
    gravity: 0.7,
    jumpStrength: 15,
    onGround: false,
    score: 0,
    respawn() {
      this.x = 50;
      this.y = 0;
      this.velocityY = 0;
    }
  };

  const keys = {};
  window.addEventListener('keydown', e => keys[e.code] = true);
  window.addEventListener('keyup', e => keys[e.code] = false);

  let platforms = [];
  let coins = [];
  let enemies = [];

  // Generate random platforms
  function generatePlatforms() {
    platforms = [];
    const platformCount = 10;
    for (let i = 0; i < platformCount; i++) {
      let width = 100 + Math.random() * 100;
      let height = 20;
      let x = Math.random() * (canvas.width - width);
      let y = Math.random() * (canvas.height - height);
      platforms.push({x, y, width, height});
    }
  }

  // Generate coins on some platforms
  function generateCoins() {
    coins = [];
    for (const plat of platforms) {
      if (Math.random() < 0.7) { // 70% chance to have a coin
        let coinX = plat.x + plat.width / 2 - 10;
        let coinY = plat.y - 20;
        coins.push({x: coinX, y: coinY, radius: 10, collected: false});
      }
    }
  }

  // Generate enemies on some platforms
  function generateEnemies() {
    enemies = [];
    for (const plat of platforms) {
      if (Math.random() < 0.5) { // 50% chance to have an enemy
        let enemyWidth = 40;
        let enemyHeight = 40;
        let enemyX = plat.x + 10;
        let enemyY = plat.y - enemyHeight;
        enemies.push({
          x: enemyX,
          y: enemyY,
          width: enemyWidth,
          height: enemyHeight,
          speed: 2 * (Math.random() > 0.5 ? 1 : -1), // Random direction
          platformXStart: plat.x,
          platformXEnd: plat.x + plat.width - enemyWidth,
        });
      }
    }
  }

  generatePlatforms();
  generateCoins();
  generateEnemies();

  // Collision detection helper
  function isColliding(rect1, rect2) {
    return !(rect1.x > rect2.x + rect2.width ||
             rect1.x + rect1.width < rect2.x ||
             rect1.y > rect2.y + rect2.height ||
             rect1.y + rect1.height < rect2.y);
  }

  // Check collision between circle and rect (for coins)
  function circleRectCollision(circle, rect) {
    const distX = Math.abs(circle.x - rect.x - rect.width / 2);
    const distY = Math.abs(circle.y - rect.y - rect.height / 2);

    if (distX > (rect.width / 2 + circle.radius)) { return false; }
    if (distY > (rect.height / 2 + circle.radius)) { return false; }

    if (distX <= (rect.width / 2)) { return true; }
    if (distY <= (rect.height / 2)) { return true; }

    const dx = distX - rect.width / 2;
    const dy = distY - rect.height / 2;
    return (dx * dx + dy * dy <= (circle.radius * circle.radius));
  }

  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Player movement left/right
    if (keys['ArrowLeft'] || keys['KeyA']) {
      player.x -= player.speedX;
    }
    if (keys['ArrowRight'] || keys['KeyD']) {
      player.x += player.speedX;
    }

    // Apply gravity
    player.velocityY += player.gravity;
    player.y += player.velocityY;

    // Prevent going off left/right edges
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

    // Check collision with platforms
    player.onGround = false;
    for (const plat of platforms) {
      if (player.velocityY >= 0 &&
          player.x < plat.x + plat.width &&
          player.x + player.width > plat.x &&
          player.y + player.height > plat.y &&
          player.y + player.height < plat.y + plat.height) {
        player.y = plat.y - player.height;
        player.velocityY = 0;
        player.onGround = true;
      }
    }

    // Jumping
    if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.onGround) {
      player.velocityY = -player.jumpStrength;
      player.onGround = false;
    }

    // Check collision with coins
    for (const coin of coins) {
      if (!coin.collected && circleRectCollision(coin, player)) {
        coin.collected = true;
        player.score++;
        scoreEl.textContent = 'Score: ' + player.score;
      }
    }

    // Move and draw enemies
    ctx.fillStyle = '#d32f2f'; // red enemy color
    for (const enemy of enemies) {
      enemy.x += enemy.speed;
      if (enemy.x < enemy.platformXStart || enemy.x > enemy.platformXEnd) {
        enemy.speed *= -1; // Reverse direction
      }
      ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);

      // Check collision with player
      if (isColliding(player, enemy)) {
        // Reset player position and score
        player.respawn();
        player.score = 0;
        scoreEl.textContent = 'Score: ' + player.score;
      }
    }

    // Draw coins
    for (const coin of coins) {
      if (!coin.collected) {
        ctx.beginPath();
        ctx.arc(coin.x, coin.y, coin.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#ffd700'; // gold coin color
        ctx.fill();
        ctx.strokeStyle = '#b8860b';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    // Draw player
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.width, player.height);

    // Draw platforms
    ctx.fillStyle = '#0f9d58';
    for (const plat of platforms) {
      ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
    }

    requestAnimationFrame(gameLoop);
  }

  gameLoop();
</script>
</body>
</html>
